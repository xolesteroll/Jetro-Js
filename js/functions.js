'use strict';
// ФУНКЦИИ

// function showFirstMessage(text) { // Негласное правило - имя функци задается в виде глагола
//     console.log(text);
//     let num = 20; // Переменная объявленная внутри функции недоступна вне ее (локальаня переменная)
// // Но в свою очередь внутри функции может быть использована глобальная переменная, заданная внее ее
// // Так же есть возможность создавать копию глобальной переменной локально внутри функции
// // они никак не будут пересекаться
// }

// showFirstMessage('Hello World'); // Вызов функции с указанием значения аргумента
// console.log(num);  // num is not defined

// function calc(a, b) {
//     return (a + b); // Окончание функции а так же возвращение значения наружу
//     // console.log('sometext'); // Код недоступен в функции после return
// }

// console.log(calc(4, 5));
// console.log(calc(12313, 1));
// console.log(calc(10, 5));

function ret() {
    let num = 50;
    return num; // В данном случае мы вытаскиваем локальную переменную наружу и можем использовать ее глобально при выхове функции
}

const anotherNum = ret(); // Создаем ппеременную и в качестве значения присваиваем ей функцию которая возвращает нам переменную

console.log(anotherNum);

const logger = function() { // так называемый Funtion expression, когда функция объявляется внутри переменной
    console.log("Hello");
}; // Тут обязательно точка запятой в отличнии от обычного объявления функции

logger(); // вызов functuion Expression, можно вызвать только после объявления

// СТРЕЛОЧНЫЕ ФУНКЦИИ (ES6+)

const calc = (a, b) => a + b; // Объявление стрелочной функции внури переменной calc (сокращенный вариант если тело функции умещается в одну стрчоку)
// (a, b) являются аргументами функции , а то что идет после => ее тело 
// Не сокращенная версия записи - const calc = (a, b) => { return a + b }; 
// Особенностю стрелочных функций является то что они не имеют своего контекста this

// CALLBACK ФУнкции - функция выполнение которой происходит после того как другая функция завершила выполнение

function first() {
    // Do Something
    setTimeout(function() {
        console.log(1);
    }, 500);
}

function second() {
    console.log(2);
}

first();
second();

function learnJS(lang, callback) { // ФУнкция callback задается в качестве второго аргумента и выполняется только после того как выполнися работа с первым аргументом
    console.log(`Я учу ${lang}`);
    callback();
}

learnJS('JavaScript', function() { // Тут мы и передаем ту callback функцию в качестве второго аргумента
    console.log('Я прошел этот урок');
});
