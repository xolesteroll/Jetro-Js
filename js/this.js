'use strict';

// Контекст вызова это окружение функции (среда), Иван привел пример с бомжом, который не имея места 
// Жительства является гражданином всего мира, но будучи помещенным в какое либо уреждение или в 
// квартиру он получает контекст вызова в виде этого учреждения или квартиры в которых он и будет функционирвоать

// Контекст вызова функции при обычном ее вызове
function showThis(a, b) { // В данном случае контекстом вызова будет глобальный объект window если не использовать
    // 'use ctrict' если же его использовать то контекст выхова будет undefined
    console.log(this);
    function sum() {
        console.log(this); // Даже если у нас используется функцуия внутри функци контескт выхова у нее не 
        // меняется
        return a + b; // засчет замыкания функции  мы можем получить аргументы из верхней функции 
    }

    console.log(sum());
}
showThis(3, 5);


// Контекс вызова функции при выхове ее в качестве метода объекта 
const obj = {
    a: 20,
    b: 15,
    sum: function() {
        console.log(this); // Контекст у методов(функций) объекта будет сам объект
        function shout() {
            console.log(this); // Так как это простой вызов функции в нутри метода объекта контекст тут будет
            // undefined как у обычной функции
        }
        shout();
    }
};

obj.sum();

// Контекст вызова функции - конструктора

function User(name, id) { // Внутри функции конструктора контекстом вызова всех свойств и методов будет только 
    // что созданный объект (новый экземлпяр объекта)
    this.name = name;
    this.id = id;
    this.human = true;
}

let ivan = new User('Ivan', 23); // Контекстом вызова будет этот объект созданный по прототипу 

// Ручное присвоение контекста
function sayName(surname) {
    console.log(this);
    console.log(this.name + surname);
}

const user = {
    name: 'John'
};


sayName.call(user, 'Smith'); // метод call() передает контекст выхова который мы хотим передать в эту функцию
// Если у функции есть какие то аргументы то эти аргументы мы передаем через запятую .
sayName.apply(user, ['Smith']); // то же самое , но в данном случае при наличии у функции аргументов мы передаем их 
// в качестве массива чередуя их запятой

// Метод bind()
function count(num) {
    return this*num;
}

const double = count.bind(2); // метод bind создает новую функцию котораякопирует функцию для которой мы 
// bindИМ контекст вызова, которым в свою очередь является аргумент заданный для метода bind в данном случае - 2

console.log(double(3));
console.log(double(103));

const btn = document.querySelector('button');

btn.addEventListener('click', function() { // в данном случае контекстом вызхова будет сам элемент на 
    // котором произошло событие (если callback функция для обработчика события написал в классическом синтаксисе)
    this.style.backgroundColor = 'red';
    console.log(this); // event.target
    // Если в обработчик событий запсать callback в виде стрелочной функции то мы не сможем получить
    // контекст вызова поэотму в таком случае лучше использовать event.target
});

// У стрелочной функции нет своего контекста вызова. Она всегда берет контекст у своего родителя

const objj = {
    num: 5,
    sayNumber: function() {
        const say = () => {
            console.log(this); // родителем этой функции является метод объекта контекстом вызова которого является 
            // сам объект, следовательно контекстом вызова данной стрелочной функции является сам объект
        };
        say();
    }
};

objj.sayNumber();

const calc = (a) => {  
    return a * 2;
};

// Если стрелочная функция вмещается в одну строку мы можем записать ее следующим образом

const calc = a => a * 2;