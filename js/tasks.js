'use strict';

// ОПервтор И всегда запинается на FALSE
// ОПервтор ИЛИ всегда запинается на TRUE

let x = 5; alert( x++ ); // = 5 потому что оператор инкримента здесь постфиксный и сначала выдается значение X а потом уже прибалвяется 1(хуй пойми короче ебала какая то)

[] + false - null + true // = NaN 
[] + false // = false (тип данных string)! сложение с пустым массивом тоже самое что сложение с пустой строкой, при этом выходит строка
'false' - null // = NaN ! Это специальное значение которое получается при выполнении не математических операций
NaN + true // == NaN ! ОЧевидно почему. Потому что при сложении чего либо  с NaN получится NaN

let b = 1; let a = b = 2; alert(a); //  = 2

[] + 1 + 2 // = 12 (тип данных string), потому что сложение с пустым массивом дает на выходе строку, и соответсвенно  в данном случае происходит конкатенация

alert( '1'[0] ); // = 1, очевидно почему

2 && 1 && null && 0 && undefined // = null , потому что оператор && всегда запинается на false, и так как первое по порядку false значение у нас null, то и получается null

!!(a && b) и (a && b) // равны ли эти выражения? очевидно что нет, двойной знак отричания дает нам на выходе boolean значение а значит не равны

alert( null || 2 && 3 || 4); // = 3, потому что по приоритету выполняется сначала оператор && и так как он оба выражения в нем true он возвращает последнее - 3
// затем срабатывает оператор ИЛИ который в свою очередь запинается на true, а первое по порядку значение true у нас 3, то соответсвенно ответ - 3

a = [1, 2, 3,]; b = [1, 2, 3]; a == b??? // Ответ нет, это разные хранилища информации с разной информацией

alert( +'Infinity'); // Ответ Infinity тип данных number

'Ежик' > 'яблоко' // false , надо смотреть таблицу Юникода

0 || '' || 2 || undefined || true || false // = 2 , потому что ИЛИ запинается на true